{
    "abstractTypeDecl": {
        "signature": "type name",
        "description": "An abstract type definition associates a name with a type without specifying the type. In generated code, the type is specified externally (e.g., as a C++ class).",
        "parameters": {
            "name": "C++ type name"
        }
    },
    "arrayDecl": {
        "signature": "array name = [ sizeExpression ] typeName (default defaultExpression)? (format formatLiteral)?",
        "description": "An array definition defines a new array type and associates a name with it.",
        "parameters": {
            "name": "Name of array",
            "sizeExpression": "Size of array",
            "typeName": "Array element type",
            "defaultExpression": "Array default value",
            "formatLiteral": "Default string literal format to include in dictionary definition"
        }
    },
    "commandDecl": {
        "signature": "commandKind command name (param-list)? (opcode opcodeExpression)? (priority priorityExpression)? queue-full-behavior?",
        "description": "A command specifier specifies a command as part of a component definition.",
        "parameters": {
            "commandKind": "The command kind specifies the kind of the command. It is similar to the kind of a port instance specifier, except that different commands on the same port can have different kinds.",
            "name": "Name of command",
            "param-list": "The parameter list specifies the command parameters. If there are no parameters, the list may be omitted. ref may not appear in any of the parameters.",
            "opcodeExpression": "opcode specifies the numeric opcode for the command. If it is present, its type must be convertible to Integer, and must evaluate to a nonnegative integer. If it is not present, then the default opcode is either zero (for the first opcode appearing in a component) or the previous opcode plus one.",
            "priorityExpression": "Specifies a priority for the command on the input queue. It must be convertible to Integer. The priority expression is valid only if the kind of the command is async.",
            "queue-full-behavior": "specifies the behavior of the command when the input full is queue. This specifier is valid only if the kind of the command is async. If no specifier appears, then the default behavior is assert."
        }
    },
    "componentInstanceDecl": {
        "signature": "instance name : component base id baseIdExpr (type C++ type)? (at includeFile)? (queue size queueSize)? (stack size stackSize)? (priority priorityExpr)? (cpu cpuExpr)? { init-specifier-sequence }",
        "description": "A component instance definition defines an instance of a component that you can refer to in a topology definition.",
        "parameters": {
            "name": "Name of component instance",
            "component": "A qualified identifier referencing a component definition",
            "baseIdExpr": [
                "Associates a base identifier with the component instance.",
                " * Must evaluate to a nonnegative integer after type conversion.",
                " * For each component instance, for each command, event, telemetry, or parameter identifier, the identifier associated with the instance is computed by adding the base identifier specified here to the relative identifier specified in the component. For this purpose, command opcodes are identifiers.",
                " * For each instance, this procedure creates a range of identifiers, from the base identifier to the largest identifier associated with the instance. If the component has no identifiers, then this range is empty.",
                " * No instance may have a base identifier that lies within the identifier range of another instance."
            ],
            "C++ type": [
                "Names the implementation type of the instance",
                "The type must be a valid type in the target language (e.g., a type name in C++). If the implementation type is not present, then the code generator infers the name of the implementation type from the component name when generating the constructor for the instance.",
                "For Example:",
                "a. Suppose an FPP model has a component C defined in module M. Suppose I is an instance of component `M.C`. By default, the implementation type associated with I is `M::C`.",
                "b. Specifying type `M::D` causes FPP to generate a constructor for I with name `M::D` instead of `M::C`.",
                "",
                "Specifying an implementation type is useful in cases where the name of the component implementation does not match the component name, e.g., because there are several implementations of the same FPP component."
            ],
            "includeFile": "File path, relative to the location of the component instance definition. The file path must name a file in the target language (e.g., a C++ header file) that provides the implementation associated with the instance. If no such path is given, then the translator uses the location of the component instance and the name of the component to generate a default implementation path.",
            "queueSize": [
                "Specifies the queue size for active and queued components. The queue size is required for active and queued components and is not allowed for passive components.",
                "Must evaluate to a nonnegative integer after type conversion."
            ],
            "stackSize": [
                "Specifies the stack size in bytes for active components. The stack size is optional for active components and is not allowed for queued or passive components.",
                "Must evaluate to a nonnegative integer after type conversion."
            ],
            "priorityExpr": "Specifies the thread priority for active components. The priority is optional for active components and is not allowed for queued or passive components.",
            "cpuExpr": "Specifies the CPU affinity for active components. The CPU affinity is optional for active components and is not allowed for queued or passive components."
        }
    },
    "componentInstanceSpec": {
        "signature": "private? instance componentInstance",
        "description": "A component instance specifier specifies that a component instance is part of a topology.",
        "parameters": {
            "componentInstance": "The qualified identifier must refer to a component instance."
        }
    },
    "constantDecl": {
        "signature": "constant name = expression",
        "description": "A constant definition associates a name with a compile-time constant value. You can use the name in place of the value elsewhere in the model.",
        "parameters": {
            "name": "Name of constant",
            "expression": "expression must evaluate to a compile-time constant value."
        }
    }
}